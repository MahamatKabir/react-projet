'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _every2 = require('lodash/every');

var _every3 = _interopRequireDefault(_every2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _invoke2 = require('lodash/invoke');

var _invoke3 = _interopRequireDefault(_invoke2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.add = add;
exports.set = set;
exports.get = get;
exports.update = update;
exports.deleteRef = deleteRef;
exports.setListener = setListener;
exports.setListeners = setListeners;
exports.unsetListener = unsetListener;
exports.unsetListeners = unsetListeners;
exports.runTransaction = runTransaction;

var _actions = require('../utils/actions');

var _constants = require('../constants');

var _query = require('../utils/query');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pathListenerCounts = {};

function add(firebase, dispatch, queryOption) {
  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var meta = (0, _query.getQueryConfig)(queryOption);
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, dispatch, meta),
    method: 'add',
    meta: meta,
    args: args,
    types: [_constants.actionTypes.ADD_REQUEST, {
      type: _constants.actionTypes.ADD_SUCCESS,
      payload: function payload(snap) {
        return { id: snap.id, data: args[0] };
      }
    }, _constants.actionTypes.ADD_FAILURE]
  });
}

function set(firebase, dispatch, queryOption) {
  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  var meta = (0, _query.getQueryConfig)(queryOption);
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, dispatch, meta),
    method: 'set',
    meta: meta,
    args: args,
    types: [_constants.actionTypes.SET_REQUEST, _constants.actionTypes.SET_SUCCESS, _constants.actionTypes.SET_FAILURE]
  });
}

function get(firebase, dispatch, queryOption) {
  var meta = (0, _query.getQueryConfig)(queryOption);

  var _ref = firebase._.config || {},
      mergeOrdered = _ref.mergeOrdered,
      mergeOrderedDocUpdates = _ref.mergeOrderedDocUpdates,
      mergeOrderedCollectionUpdates = _ref.mergeOrderedCollectionUpdates;

  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, dispatch, meta),
    method: 'get',
    meta: meta,
    types: [_constants.actionTypes.GET_REQUEST, {
      type: _constants.actionTypes.GET_SUCCESS,
      payload: function payload(snap) {
        return {
          data: (0, _query.dataByIdSnapshot)(snap),
          ordered: (0, _query.orderedFromSnap)(snap)
        };
      },
      merge: {
        docs: mergeOrdered && mergeOrderedDocUpdates,
        collections: mergeOrdered && mergeOrderedCollectionUpdates
      }
    }, _constants.actionTypes.GET_FAILURE]
  });
}

function update(firebase, dispatch, queryOption) {
  for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
    args[_key3 - 3] = arguments[_key3];
  }

  var meta = (0, _query.getQueryConfig)(queryOption);
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, dispatch, meta),
    method: 'update',
    meta: meta,
    args: args,
    types: [_constants.actionTypes.UPDATE_REQUEST, _constants.actionTypes.UPDATE_SUCCESS, _constants.actionTypes.UPDATE_FAILURE]
  });
}

function deleteRef(firebase, dispatch, queryOption) {
  var meta = (0, _query.getQueryConfig)(queryOption);
  var config = firebase._.config;

  if (!meta.doc || meta.subcollections && !(0, _every3.default)(meta.subcollections, 'doc')) {
    if ((0, _isFunction3.default)(config.onAttemptCollectionDelete)) {
      return config.onAttemptCollectionDelete(queryOption, dispatch, firebase);
    }
    return Promise.reject(new Error('Only documents can be deleted.'));
  }
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, dispatch, meta),
    method: 'delete',
    meta: meta,
    types: [_constants.actionTypes.DELETE_REQUEST, {
      type: _constants.actionTypes.DELETE_SUCCESS,
      preserve: firebase._.config.preserveOnDelete
    }, _constants.actionTypes.DELETE_FAILURE]
  });
}

var changeTypeToEventType = {
  added: _constants.actionTypes.DOCUMENT_ADDED,
  removed: _constants.actionTypes.DOCUMENT_REMOVED,
  modified: _constants.actionTypes.DOCUMENT_MODIFIED
};

function docChangeEvent(change) {
  var originalMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var meta = _extends({}, originalMeta, { path: change.doc.ref.path });
  if (originalMeta.subcollections && !originalMeta.storeAs) {
    meta.subcollections[0] = _extends({}, meta.subcollections[0], { doc: change.doc.id });
  } else {
    meta.doc = change.doc.id;
  }
  return {
    type: changeTypeToEventType[change.type] || _constants.actionTypes.DOCUMENT_MODIFIED,
    meta: meta,
    payload: {
      data: change.doc.data(),
      ordered: { oldIndex: change.oldIndex, newIndex: change.newIndex }
    }
  };
}

function setListener(firebase, dispatch, queryOpts, successCb, errorCb) {
  var meta = (0, _query.getQueryConfig)(queryOpts);

  var _ref2 = firebase._.config || {},
      mergeOrdered = _ref2.mergeOrdered,
      mergeOrderedDocUpdates = _ref2.mergeOrderedDocUpdates,
      mergeOrderedCollectionUpdates = _ref2.mergeOrderedCollectionUpdates;

  var unsubscribe = (0, _query.firestoreRef)(firebase, dispatch, meta).onSnapshot(function (docData) {
    var docChanges = typeof docData.docChanges === 'function' ? docData.docChanges() : docData.docChanges;

    if (docChanges && docChanges.length < docData.size) {
      if (docChanges.length === 1) {
        dispatch(docChangeEvent(docChanges[0], meta));
      } else {
        docChanges.forEach(function (change) {
          dispatch(docChangeEvent(change, meta));
        });
      }
    } else {
      dispatch({
        type: _constants.actionTypes.LISTENER_RESPONSE,
        meta: meta,
        payload: {
          data: (0, _query.dataByIdSnapshot)(docData),
          ordered: (0, _query.orderedFromSnap)(docData)
        },
        merge: {
          docs: mergeOrdered && mergeOrderedDocUpdates,
          collections: mergeOrdered && mergeOrderedCollectionUpdates
        }
      });
    }

    if (successCb) successCb(docData);
  }, function (err) {
    var _ref3 = firebase._.config || {},
        logListenerError = _ref3.logListenerError,
        preserveOnListenerError = _ref3.preserveOnListenerError;

    if (logListenerError) (0, _invoke3.default)(console, 'error', err);
    dispatch({
      type: _constants.actionTypes.LISTENER_ERROR,
      meta: meta,
      payload: err,
      merge: {
        docs: mergeOrdered && mergeOrderedDocUpdates,
        collections: mergeOrdered && mergeOrderedCollectionUpdates
      },
      preserve: preserveOnListenerError
    });

    if (errorCb) errorCb(err);
  });
  (0, _query.attachListener)(firebase, dispatch, meta, unsubscribe);
}

function setListeners(firebase, dispatch, listeners) {
  if (!(0, _isArray3.default)(listeners)) {
    throw new Error('Listeners must be an Array of listener configs (Strings/Objects).');
  }

  var config = firebase._.config;

  if (config.oneListenerPerPath) {
    return listeners.forEach(function (listener) {
      var path = (0, _query.getQueryName)(listener);
      var oldListenerCount = pathListenerCounts[path] || 0;
      pathListenerCounts[path] = oldListenerCount + 1;

      if (oldListenerCount > 0) {
        return;
      }

      setListener(firebase, dispatch, listener);
    });
  }

  return listeners.forEach(function (listener) {
    var multipleListenersEnabled = (0, _isFunction3.default)(config.allowMultipleListeners) ? config.allowMultipleListeners(listener, firebase._.listeners) : config.allowMultipleListeners;

    if (!(0, _query.listenerExists)(firebase, listener) || multipleListenersEnabled) {
      setListener(firebase, dispatch, listener);
    }
  });
}

function unsetListener(firebase, dispatch, opts) {
  return (0, _query.detachListener)(firebase, dispatch, (0, _query.getQueryConfig)(opts));
}

function unsetListeners(firebase, dispatch, listeners) {
  if (!(0, _isArray3.default)(listeners)) {
    throw new Error('Listeners must be an Array of listener configs (Strings/Objects).');
  }
  var config = firebase._.config;

  if (config.oneListenerPerPath) {
    listeners.forEach(function (listener) {
      var path = (0, _query.getQueryName)(listener);
      pathListenerCounts[path] -= 1;

      if (pathListenerCounts[path] === 0) {
        unsetListener(firebase, dispatch, listener);
      }
    });

    return;
  }

  listeners.forEach(function (listener) {
    unsetListener(firebase, dispatch, listener);
  });
}

function runTransaction(firebase, dispatch, transactionPromise) {
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: firebase.firestore(),
    method: 'runTransaction',
    args: [transactionPromise],
    types: [_constants.actionTypes.TRANSACTION_START, _constants.actionTypes.TRANSACTION_SUCCESS, _constants.actionTypes.TRANSACTION_FAILURE]
  });
}

exports.default = {
  get: get,
  firestoreRef: _query.firestoreRef,
  add: add,
  update: update,
  setListener: setListener,
  setListeners: setListeners,
  unsetListener: unsetListener,
  unsetListeners: unsetListeners,
  runTransaction: runTransaction
};